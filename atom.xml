<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Avery&#39;s blog</title>
  
  <subtitle>外接海馬體連線中...</subtitle>
  <link href="https://avery210412.github.io/atom.xml" rel="self"/>
  
  <link href="https://avery210412.github.io/"/>
  <updated>2022-04-30T15:55:33.831Z</updated>
  <id>https://avery210412.github.io/</id>
  
  <author>
    <name>Avery</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>[JS101] JavaScript Runtime Environment</title>
    <link href="https://avery210412.github.io/javascript/javascript-runtime-environment/"/>
    <id>https://avery210412.github.io/javascript/javascript-runtime-environment/</id>
    <published>2022-04-30T15:39:00.000Z</published>
    <updated>2022-04-30T15:55:33.831Z</updated>
    
    <content type="html"><![CDATA[<p>本篇將釐清 JavaScript 在不同執行環境（runtime）的差別。</p><span id="more"></span><p>JavaScript 是一個程式語言，會有程式語言本身所規範可以用的東西，例如用 <code>var</code> 宣告變數，用 <code>if else</code> 進行條件判斷，或者是使用 <code>function</code> 宣告函式，這些東西都是 JavaScript 這個程式語言本身就有的部分。</p><p>既然上面說了「程式語言本身就有的部分」，就代表也有一些東西其實是「不屬於 JavaScript 這個程式語言的」。</p><p>例如 <code>document.querySelector('body')</code>，可以拿到 body 的 DOM 物件並且對它做操作，而操作之後會即時反應在瀏覽器的畫面上。這個 <code>document</code> 是哪來的？其實是<strong>瀏覽器提供給 JavaScript 的</strong>，這樣才能讓 JavaScript 透過 <code>document</code> 這個物件與瀏覽器進行溝通來操控 DOM。</p><p>如果去翻 <strong>ECMAScript</strong> 的文件，會發現裡面完全沒有出現 <code>document</code> 這個東西，因為它不是這個程式語言本身的一部份，而是瀏覽器提供的東西。如果在瀏覽器上面跑 JavaScript，可以<strong>把瀏覽器稱作是 JavaScript 的「執行環境（runtime）」</strong>，因為 JavaScript 就是在瀏覽器上執行，十分合理。除了 <code>document</code> 以外，像是拿來計時的 <code>setTimeout</code> 與 <code>setInterval</code>，拿來做 ajax 的 <code>XMLHttpRequest</code> 與 <code>fetch</code>，這些都是瀏覽器這個執行環境所提供的東西。</p><p>除了瀏覽器以外，還有其他 JavaScript 的執行環境，就叫做 Node.js。</p><blockquote><p>Node.js® is a JavaScript runtime built on Chrome’s V8 JavaScript engine.</p></blockquote><p>所以 JavaScript 程式碼可以選擇跑在瀏覽器上，透過瀏覽器這個執行環境提供的東西操控畫面，或者是發 Request 出去；也可以選擇跑在 Node.js 這個執行環境上面，使用 Node.js 提供的東西。</p><p>那 Node.js 提供了什麼呢？例如 <code>fs</code>，全名為 <strong>file system</strong>，是控制檔案的介面，可以用 JavaScript 來讀寫電腦裡的檔案；還提供了 <code>http</code> 這個模組，可以用 JavaScript 來寫 server。</p><p>詳情請參考底下的示意圖：</p><p><img src="https://static.coderbridge.com/img/techbridge/images/huli/js-async/p1.png" alt="JavaScript runtime"></p><p>可以很清楚地看到當 JavaScript 在不同環境底下執行時，可以用的東西也不一樣，端看執行環境提供了什麼。</p><p>上圖中 <code>setTimeout</code> 在兩個環境都有出現，因為這兩個環境都覺得<strong>計時器</strong>這功能很重要，所以都提供了 <code>setTimeout</code> 這個函式給開發者使用。在兩個環境上的功能雖然是一模一樣的，但要注意的是<strong>因為執行環境不同，所以背後的實作方式以及原理也不同</strong>。</p><p>另外，執行環境不同，執行方式也會不同。以瀏覽器來說，是用 <code>&lt;script src=&quot;index.js&quot;&gt;</code> 去引入一個 JavaScript 檔案，就可以在瀏覽器上執行；以 Node.js 來說，必須先在電腦上安裝 Node.js 這個執行環境，然後以 CLI 的方式輸入 <code>node index.js</code> 這個指令來執行。</p><p>整理一下重點：</p><ol><li><p>JavaScript 只是一個程式語言，需要搭配<strong>執行環境</strong>提供的東西才能有效使用，例如：<code>setTimeout</code>、<code>document</code> 等</p></li><li><p>最常見的 JavaScript 執行環境有兩個，一個是瀏覽器，一個是 Node.js</p></li><li><p>不同的執行環境會提供不同的東西，例如：Node.js 提供了 <code>http</code> 這個模組讓 JavaScript 可以寫一個伺服器，但瀏覽器就沒有提供這種東西</p></li></ol><h2 id="參考資料">參考資料</h2><p><a href="https://blog.huli.tw/2019/10/04/javascript-async-sync-and-callback/">JavaScript 中的同步與非同步（上）：先成為 callback 大師吧！</a></p><p><a href="https://ithelp.ithome.com.tw/articles/10191345">不只是瀏覽器！JavaScript 征服世界的第一步 - Node.js</a></p><p><a href="https://ithelp.ithome.com.tw/articles/10242676">在不同 runtime 上執行的 JavaScript</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本篇將釐清 JavaScript 在不同執行環境（runtime）的差別。&lt;/p&gt;</summary>
    
    
    
    <category term="javascript" scheme="https://avery210412.github.io/categories/javascript/"/>
    
    
    <category term="Lidemy" scheme="https://avery210412.github.io/tags/Lidemy/"/>
    
    <category term="JavaScript" scheme="https://avery210412.github.io/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>[GIT101] Git Version Control</title>
    <link href="https://avery210412.github.io/tool/git-version-control/"/>
    <id>https://avery210412.github.io/tool/git-version-control/</id>
    <published>2022-04-29T04:36:44.000Z</published>
    <updated>2022-04-30T15:24:51.215Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言-2">前言</h2><p>在軟體開發領域，對原始碼進行<strong>版本控管</strong>是非常重要的一件事。Git 是一套分散式版本控管系統（Distributed Version Control System），支援本地操作、遠端協作、彈性的分支與合併、原始碼審核（Code Review）等功能，對專案原始碼的品質管理很有幫助。</p><span id="more"></span><h2 id="What-is-Git？">What is Git？</h2><p>一個檔案可能會經過多次的修改，如果將每一次的修改都保存下來，這個行為就是「版本控制」。一般使用者在進行版本控制的時候，大多都是以「資料夾」為單位，如下圖所示：</p><p><img src="https://imgur.com/CWDES3g.png" alt="version control by folder"></p><p>現在有一個名為 <code>resume</code> 的目錄，目錄最初存放了 3 個檔案。在此之後也許會對 <code>resume</code> 目錄中的檔案有些操作，不論是新增、刪除檔案，或是修改檔案內容，只要「<code>resume</code> 目錄的<strong>狀態有變化</strong>」，就稱之為一個「<strong>版本</strong>」。</p><p><img src="https://imgur.com/dr2C7BQ.png" alt="version control"></p><p>以日期為目錄名稱進行版本控制，雖然可以知道在什麼時間點修改過檔案，但是卻不能在第一時間反應，在那個時間點對檔案做了什麼變動，也無法比較兩個時間點間的檔案差異。</p><p>Git 就是一種版本控制系統，清楚地記錄每個檔案在什麼時候被新增、什麼時候被修改或刪除，透過 Commit Message 可以看到以前的歷史紀錄、和上一個版本差異；在多人協作方面，Git 擁有快速的分支與合併機制，強力支援分散式開發模式，有效率的處理大型專案。</p><h2 id="Git-基本指令">Git 基本指令</h2><h3 id="初始化目錄">初始化目錄</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /desktop              <span class="comment"># 切換至 /desktop 目錄</span></span><br><span class="line">$ <span class="built_in">mkdir</span> git-practice       <span class="comment"># 建立 git-practice 目錄</span></span><br><span class="line">$ <span class="built_in">cd</span> git-practice          <span class="comment"># 切換至 git-practice 目錄</span></span><br><span class="line">$ git init                 <span class="comment"># 初始化目錄，讓 Git 對這個目錄開始進行版控</span></span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /desktop/git-practice/.git/</span><br></pre></td></tr></table></figure><p><code>git init</code> 會在目錄建立一個 <code>.git</code> 隱藏目錄，整個版控的精華就在這裡面。</p><div class="note danger">            <p>🔴<strong>注意</strong><br>空的目錄是無法被 Commit 的，因為 Git 在計算、產生物件的時候，是根據「<strong>檔案變化的內容</strong>」去做計算的，內容不可以為空。</p>          </div> <h3 id="查詢目錄狀態">查詢目錄狀態</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">nothing to commit (create/copy files and use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure><p>在這個目錄裡，除了 Git 初始化目錄後產生的 <code>.git</code> 隱藏目錄外，其他什麼都沒有，所以上面這段訊息的意思是「現在沒有東西可以提交（nothing to commit）」。</p><h3 id="加入版控追蹤">加入版控追蹤</h3><p>在目錄裡新增一個 <code>index.html</code> 檔案，使用 <code>git status</code> 指令查詢目錄狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> index.html</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        index.html</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure><p><code>index.html</code> 檔案目前的狀態是 <strong>Untracked files</strong>，意思是這個檔案<strong>尚未被加到 Git 版控系統</strong>裡，還沒開始正式被 Git「追蹤」，它只是剛剛才加入這個目錄而已。</p><p>使用 <code>git add index.html</code> 指令，將 <code>index.html</code> 檔案交給 Git，讓 Git 開始追蹤它。再次使用 <code>git status</code> 指令查詢目錄狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ git add index.html</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   index.html</span><br></pre></td></tr></table></figure><p><code>index.html</code> 檔案的狀態從 <strong>Untracked files</strong> 變成 <strong>new file</strong> 狀態了，表示這個檔案已經被安置到<strong>暫存區</strong>（<strong>Staging Area</strong>），等待稍後跟其它檔案一起被存到<strong>儲存庫</strong>（<strong>Repository</strong>）裡。</p><div class="note ">            <p>🌀<strong>狀況題</strong><br>如果在 <code>git add</code> 之後，又修改了那個檔案的內容？</p><p>在 <code>index.html</code> 檔案被安置到<strong>暫存區</strong>後，又對這個檔案進行了修改，使用 <code>git status</code> 指令查詢目錄狀態：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">No commits yet</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git rm --cached &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        new file:   index.html</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        modified:   index.html</span><br></pre></td></tr></table></figure><p>對 Git 來說，<code>index.html</code> 檔案修改後的內容並沒有被加到暫存區裡，所以這時候在暫存區裡的 <code>index.html</code> 檔案是維持在<strong>修改前</strong>的狀態。如果確定檔案修改完畢，再次使用 <code>git add index.html</code> 指令，將 <code>index.html</code> 檔案安置到暫存區中。</p>          </div><h3 id="把暫存區的內容提交到儲存庫裡存檔">把暫存區的內容提交到儲存庫裡存檔</h3><p>要讓暫存區的內容永久地保存下來，需要使用 <code>git commit</code> 指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git commit -m <span class="string">&#x27;&lt;create&gt; index.html&#x27;</span></span><br><span class="line">[master (root-commit) 7f7ec9c] &lt;create&gt; index.html</span><br><span class="line"> 1 file changed, 9 insertions(+)</span><br><span class="line"> create mode 100644 index.html</span><br></pre></td></tr></table></figure><p>對 Git 來說，<code>git commit</code> 的意思是「<strong>把暫存區（Staging Area）的東西存放到儲存庫（Repository）裡</strong>」，對開發者而言，就是「我完成一個存檔（備份）的動作了」，這樣就建立了一個新的版本。</p><p>在 <code>git commit</code> 後面加上 <code>-m '&lt;create&gt; index.html'</code> 的用意是說明「在這次的 Commit 做了什麼事」。在 Commit 的時候，如果沒有輸入這個訊息，Git 預設是不會讓你完成此次的 Commit。Commit Message 最主要的目的就是告訴自己以及其它人「這次的修改做了什麼」。</p><p><img src="https://imgur.com/Nb1sc7J.png" alt="Git all state"></p><div class="note danger">            <p>🔴<strong>注意</strong><br>要完成 <code>git commit</code> 指令，才是<strong>完整建立了一個版本</strong>的流程。每一次的 Commit 都只會處理暫存區裡的內容。</p>          </div><h3 id="檢視提交的歷史記錄">檢視提交的歷史記錄</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit 7f7ec9cf6b7d1bdbc3972c8882f1278b9414d35e (HEAD -&gt; master)</span><br><span class="line">Author: AveryChen &lt;avery210412@gmail.com&gt;</span><br><span class="line">Date:   Tue Apr 26 23:03:16 2022 +0800</span><br><span class="line"></span><br><span class="line">    &lt;create&gt; index.html</span><br></pre></td></tr></table></figure><p>最新提交的 Commit 會先被列出來，歷史紀錄會列出每筆 Commit 的 SHA-1 校驗碼、作者名字與電子郵件、寫入日期以及 Commit Message 等資訊。</p><h3 id="Git-檔案追蹤機制">Git 檔案追蹤機制</h3><p><img src="https://imgur.com/eY3vFN8.png" alt="Git file tracking"></p><ul><li><p>Untracked file：尚未被追蹤的檔案</p></li><li><p>Changes to be committed：已加入暫存區，準備變成一個 Commit 的檔案</p></li><li><p>Changes not staged for commit：尚未加入到暫存區，但有被加入到追蹤的檔案</p></li></ul><h3 id="刪除檔案-變更檔名">刪除檔案 / 變更檔名</h3><h4 id="刪除檔案">刪除檔案</h4><p>在 Git 裡，不管是刪除檔案或是變更檔名，對 Git 來說都是一種「修改」。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> index.html</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        deleted:   index.html</span><br></pre></td></tr></table></figure><p><code>index.html</code> 檔案目前的狀態是 <strong>deleted</strong>，而且已經被安置到暫存區中，可以直接進行 Commit。</p><p>如果只是想把檔案從 <code>.git</code> 目錄中移除，<strong>不再進行 Git 版本控制</strong>，可以在 <code>git rm &lt;file&gt;</code> 指令後面加上 <code>-–cached</code> 參數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">rm</span> index.html --cache</span><br><span class="line"><span class="built_in">rm</span> <span class="string">&#x27;index.html&#x27;</span></span><br></pre></td></tr></table></figure><p>這個訊息並不是真的把 <code>index.html</code> 檔案刪除了，只是把檔案從 Git 裡移除而已。使用 <code>git status</code> 指令查詢目錄狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        deleted:    index.html</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line"></span><br><span class="line">        index.html</span><br></pre></td></tr></table></figure><p><code>index.html</code> 檔案的狀態從原本已經在暫存區裡的 <strong>Staged</strong> 變成 <strong>Untracked</strong>，這個檔案就沒有在 Git 版本控制的範圍內了。</p><h4 id="變更檔名">變更檔名</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">mv</span> index.html home.html</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use <span class="string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)</span><br><span class="line"></span><br><span class="line">        renamed:   index.html -&gt; home.html</span><br></pre></td></tr></table></figure><p><code>index.html</code> 檔案目前的狀態是 <strong>renamed</strong>，而且已經被安置到暫存區中，可以直接進行 Commit。</p><h3 id="取消刪除-修改檔案">取消刪除 / 修改檔案</h3><p>在 Git 裡面如果不小心把檔案或目錄刪掉是救得回來的，而當你修改某個檔案但後悔了，也可以把檔案回復成它上一次 Commit 的狀態。</p><p>使用 <code>git checkout &lt;file&gt;</code> 指令，可以把檔案從 <code>.git</code> 目錄裡拉一份到目前的工作目錄（Working Directory），也就是說這個指令<strong>會把暫存區裡的內容，拿來覆蓋工作目錄的內容</strong>，它會把檔案回復到上一次 Commit 的狀態。</p><ul><li>刪除專案裡所有 HTML 檔案</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">rm</span> *.html</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Changes not staged <span class="keyword">for</span> commit:</span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> to update what will be committed)</span><br><span class="line">  (use <span class="string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="keyword">in</span> working directory)</span><br><span class="line"></span><br><span class="line">        deleted:   about.html</span><br><span class="line">        deleted:   home.html</span><br><span class="line">        deleted:   index.html</span><br><span class="line">        deleted:   product.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>把被刪除的 <code>home.html</code> 檔案救回來：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout home.html</span><br><span class="line">Updated 1 path from the index</span><br></pre></td></tr></table></figure><ul><li>把所有被刪掉的檔案救回來：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout .</span><br><span class="line">Updated 3 paths from the index</span><br></pre></td></tr></table></figure><h3 id="修改-Commit-紀錄">修改 Commit 紀錄</h3><p>原本的歷史紀錄是這個樣子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">e624291 (HEAD -&gt; master) &lt;update&gt;</span><br><span class="line">7f7ec9c &lt;create&gt; index.html</span><br></pre></td></tr></table></figure><p>需要修改<strong>最近一期</strong>的 Commit Message，在 <code>git commit</code> 指令後面加上 <code>--amend</code> 參數：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git commit --amend -m <span class="string">&#x27;&lt;update&gt; rename index.html to home.html&#x27;</span></span><br><span class="line">[master 51032f3] &lt;update&gt; rename index.html to home.html</span><br><span class="line">  Date: Wed Apr 27 07:48:41 2022 +0800</span><br><span class="line">  1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">  rename index.html =&gt; home.html (100%)</span><br></pre></td></tr></table></figure><p>再次使用 <code>git log</code> 指令查詢歷史紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">51032f3 (HEAD -&gt; master) &lt;update&gt; rename index.html to home.html</span><br><span class="line">7f7ec9c &lt;create&gt; index.html</span><br></pre></td></tr></table></figure><p>雖然只是修改 Commit Message，其它檔案內容都沒有修改，但對 Git 來說，因為 <strong>Commit Message 的內容</strong>改變了，所以 Git 會重新計算並產生一個全新的 Commit。</p><div class="note danger">            <p>🔴<strong>注意</strong><br>盡量不要在已經 Push 出去之後再修改 Commit Message，否則可能會造成其它開發者的困擾。</p>          </div><p>如果檔案臨時做了一些小修改，不想再提交一個新的 Commit；或者是需要追加檔案到<strong>最近一期</strong>的 Commit，例如新增一個 <code>style.css</code> 檔案到目錄中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> style.css</span><br><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line"></span><br><span class="line">Untracked files:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="keyword">in</span> what will be committed)</span><br><span class="line">        </span><br><span class="line">        style.css</span><br><span class="line"></span><br><span class="line">nothing added to commit but untracked files present (use <span class="string">&quot;git add&quot;</span> to track)</span><br></pre></td></tr></table></figure><p>可以使用 <code>--amend</code> 參數進行 Commit，將 <code>style.css</code> 檔案併入最後一次的 Commit：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git add style.css</span><br><span class="line">$ git commit --amend -m <span class="string">&#x27;&lt;update / create&gt; index.html / style.css&#x27;</span></span><br><span class="line">[master c40dda8] &lt;update / create&gt; index.html / style.css</span><br><span class="line">  Date: Wed Apr 27 07:48:41 2022 +0800</span><br><span class="line">  2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">  rename index.html =&gt; home.html (100%)</span><br><span class="line">  create mode 100644 style.css</span><br></pre></td></tr></table></figure><p>使用 <code>git log</code> 指令查詢歷史紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">c40dda8 (HEAD -&gt; master) &lt;update / create&gt; index.html / style.css</span><br><span class="line">7f7ec9c &lt;create&gt; index.html</span><br></pre></td></tr></table></figure><h3 id="Git-版本還原">Git 版本還原</h3><p>當送出 Commit 之後卻後悔了，有可能是發現了修改的檔案裡有 bugs，因此想要取消這次的 Commit，可以使用 <code>git reset</code> 指令。</p><p>Reset 這個英文單字的翻譯是「重新設定」，但事實上 <code>git reset</code> 指令用中文來說比較像是「前往」，也就是「go to」的概念。因為實際上 <code>git reset</code> 並不是真的刪除或是重新設定 Commit，只是「前往」到指定的 Commit，那些看起來好像不見的東西只是暫時看不到，但隨時都可以再撿回來。</p><p>使用 <code>git log</code> 指令查詢歷史紀錄：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">9dcfb12 (HEAD -&gt; master) &lt;create&gt; database.yml <span class="keyword">in</span> config folder</span><br><span class="line">babb78d &lt;create&gt; product.html</span><br><span class="line">d2ba818 &lt;create&gt; index.html</span><br><span class="line">9d5b7d1 &lt;create&gt; about.html</span><br><span class="line">c49e0a8 &lt;crete&gt; gitignore</span><br><span class="line">c40dda8 &lt;update / create&gt; index.html / style.css</span><br><span class="line">7f7ec9c &lt;create&gt; index.html</span><br></pre></td></tr></table></figure><p>如果想要拆掉<strong>最後一次</strong>的 Commit，也就是回到前一次 Commit，可以使用「<strong>相對</strong>」或「<strong>絕對</strong>」的做法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用相對作法</span></span><br><span class="line">$ git reset 9dcfb12^</span><br><span class="line">$ git reset master^</span><br><span class="line">$ git reset HEAD^</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用絕對做法</span></span><br><span class="line">$ git reset babb78d</span><br></pre></td></tr></table></figure><h3 id="Reset-的模式">Reset 的模式</h3><table><thead><tr><th>模式</th><th>mixed</th><th>soft</th><th>hard</th></tr></thead><tbody><tr><td>工作目錄（Untracked）</td><td>不變</td><td>不變</td><td>不變</td></tr><tr><td>工作目錄（Modified）</td><td>不變</td><td>不變</td><td>捨棄</td></tr><tr><td>暫存區</td><td>丟回工作目錄</td><td>不變</td><td>捨棄</td></tr><tr><td>拆分 Commit，從儲存庫被拆出的檔案</td><td>丟回工作目錄</td><td>丟回暫存區</td><td>捨棄</td></tr></tbody></table><h4 id="Soft-reset">Soft reset</h4><p><img src="https://imgur.com/sFl6rsZ.gif" alt="soft reset"></p><h4 id="Hard-reset">Hard reset</h4><p><img src="https://imgur.com/rOFASNC.gif" alt="hard reset"></p><h3 id="忽略不要版本控制的檔案">忽略不要版本控制的檔案</h3><p>一些比較機密的檔案，例如：資料庫的存取密碼、AWS 伺服器的存取金鑰；或是一些程式碼編譯的中間檔、暫存檔，不想放在 Git 裡面一起備份，只要在專案目錄裡放一個 <code>.gitignore</code> 檔案，並且設定想要忽略的規則就行了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># .gitignore.text</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 secret.yml 檔案</span></span><br><span class="line">secret.yml   </span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略 config 目錄下的 database.yml 檔案</span></span><br><span class="line">config/database.yml</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有 db 目錄下附檔名是 .sqlite3 的檔案</span></span><br><span class="line">/db/*.sqlite3</span><br><span class="line"></span><br><span class="line"><span class="comment"># 忽略所有附檔名是 .tmp 的檔案</span></span><br><span class="line">*.tmp</span><br></pre></td></tr></table></figure><div class="note danger">            <p>🔴<strong>注意</strong><br><code>.gitignore</code> 檔案設定的規則，只針對在規則設定之後有成效，對於在 <code>.gitignore</code> 檔案設定規則以前，就已經存在的檔案就像既得利益者一樣，這些規則是對他們沒有效果的。</p>          </div><h3 id="拿到一個新專案的步驟">拿到一個新專案的步驟</h3><ol><li><p>加入版本控制 <code>git init</code></p></li><li><p>建立 <code>.gitignore</code> 排除需要忽略的檔案，<code>.gitignore</code> 檔案也需要加入版控（其他協作者才知道）</p></li><li><p>使用 <code>git add .</code> 將檔案加入版控，因為是<strong>新建立的檔案</strong>，不能直接使用 <code>git commit -am</code>（新增的檔案還不在暫存區）</p></li><li><p>如果是<strong>已經加入版控</strong>的檔案，可以直接使用 <code>git commit -am</code> 合併指令</p></li><li><p>建立 <code>develop</code>、<code>feature</code> 分支，進行開發作業</p></li></ol><h2 id="使用分支（branch）">使用分支（branch）</h2><p>在增加新功能、修正 bug，或是想嘗試一些新做法時，都可以另外開一個分支來進行，等開發完確認沒問題之後再合併回來，就不會影響正在運行的功能。簡而言之，branch 的作用就是讓開發過程各自獨立。</p><p><img src="https://imgur.com/wQmzfvH.png" alt="branch"></p><h3 id="分支的本質">分支的本質</h3><p>在 Git 裡⾯的分⽀，其實就跟<strong>⼀張貼紙</strong>⼀樣，它會貼在某個 Commit 上：</p><p><img src="https://imgur.com/eAJMurC.png" alt="branch"></p><p>當完成了一個新的 Commit，新的 Commit 會指向它的前一個 Commit，而目前的分支，會貼到剛剛完成的新的 Commit 上。也就是說分支會隨著每次 Commit 的新增一起移動：</p><p><img src="https://imgur.com/Edjec69.png" alt="branch on new commit"></p><p>在 Git 的分⽀並不是複製⽬錄或檔案來進⾏開發與修改，<strong>分⽀就只是⼀個指標、⼀張貼紙，貼在某個 Commit 上⾯⽽已</strong>。</p><h3 id="查看專案分支">查看專案分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="建立分支">建立分支</h3><p>開發新功能之前，養成建立新分支的好習慣。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git branch develop</span><br><span class="line">$ git branch</span><br><span class="line">  develop</span><br><span class="line">* master</span><br></pre></td></tr></table></figure><h3 id="切換分支">切換分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout develop</span><br><span class="line">Switched to branch <span class="string">&#x27;develop&#x27;</span></span><br><span class="line"></span><br><span class="line">$ git branch</span><br><span class="line">* develop</span><br><span class="line">  master</span><br></pre></td></tr></table></figure><h4 id="在切換分⽀的時候發⽣了什麼事？">在切換分⽀的時候發⽣了什麼事？</h4><ol><li><p>更新暫存區以及⼯作⽬錄</p><p>Git 在切換分⽀的時候，會⽤該分⽀指向的那個 Commit 的內容來「更新」暫存區以及⼯作⽬錄。但是<strong>在切換分⽀之前所做的修改則還是會留在⼯作⽬錄</strong>，也就是說換切分⽀並<strong>不會影響已經在⼯作⽬錄的那些修改</strong>。</p></li><li><p>變更 HEAD 的位置</p><p>除了更新暫存區以及⼯作⽬錄的內容外，同時 HEAD 也會指向剛剛切換過去的那個分⽀，也就是說 <code>.git/HEAD</code> 這個檔案會跟著被修改。</p></li></ol><h3 id="修改分支名稱">修改分支名稱</h3><p>分支改名<strong>不會影響到檔案或目錄</strong>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -m &lt;old branch-name&gt; &lt;new branch-name&gt;</span><br></pre></td></tr></table></figure><h3 id="刪除分支">刪除分支</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git branch feature</span><br><span class="line">$ git branch</span><br><span class="line">* develop</span><br><span class="line">  feature</span><br><span class="line">  master</span><br><span class="line">$ git branch -d feature</span><br><span class="line">Deleted branch feature (was babb78d).</span><br></pre></td></tr></table></figure><p>如果要刪除的分支還沒被完全合併，Git 會有小提示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d feature</span><br><span class="line">error: The branch <span class="string">&#x27;feature&#x27;</span> is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run <span class="string">&#x27;git branch -D cat&#x27;</span>.</span><br></pre></td></tr></table></figure><p>如果刪除了<strong>尚未被合併完成</strong>的分支，但事後反悔了想將檔案救回來，還是有方法可行的。</p><p><img src="https://imgur.com/BOWWGhq.png" alt="delete unmerged branch"></p><p>從上圖可以看到，即便刪除了分支，但在該分支上原先的 Commit 依然保存著，那是因為<strong>分支只是一個指向某個 Commit 的指標，刪除這個指標並不會造成那些 Commit 消失</strong>。既然 Commit 沒有消失，就意味著還是可以重新把它找回來：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch return_dev b174a5</span><br></pre></td></tr></table></figure><p>這個指令的意思是「建立一個名為 <code>return_dev</code> 的分支，讓它指向 <code>b174a5a</code> 這個 Commit」，簡單來說就是再去拿一張新的貼紙貼回去的意思。</p><div class="note warning">            <p>🌕<strong>補充</strong><br>如果沒有把被刪除的分支的 SHA-1 值記下來，該怎麼復原？</p><p>可以使用 <code>git reflog</code> 指令去查找。當 <code>HEAD</code> 有移動的時候（例如：切換分支或是 reset，都會造成 <code>HEAD</code> 移動），Git 就會在 Reflog 裡記上一筆。</p>          </div><h3 id="合併分支">合併分支</h3><p>當在 <code>develop</code> 分支開發完新功能，要將功能上線到穩定系統，也就是把 <code>develop</code> 分支合併到主要分支 <code>master</code>，需要以下步驟：</p><ol start="0"><li><p>使用 <code>git log</code> 指令查詢歷史紀錄：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">log</span> --oneline</span><br><span class="line">87e0bb8 (HEAD -&gt; develop) &lt;create&gt; product management feature</span><br><span class="line">a3664cb &lt;create&gt; product page</span><br><span class="line">6b9bf18 (master) &lt;create&gt; main feature</span><br><span class="line">dbbcdd9 &lt;create&gt; home style</span><br><span class="line">4c6862a &lt;create&gt; home page</span><br></pre></td></tr></table></figure></li><li><p>切回主要分支 <code>master</code></p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch <span class="string">&#x27;master&#x27;</span></span><br></pre></td></tr></table></figure></li><li><p>輸入要合併的分支名稱</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git merge develop</span><br><span class="line">Updating 6b9bf18..87e0bb8</span><br><span class="line">Fast-forward</span><br><span class="line">product.html | 0</span><br><span class="line">product.js   | 0</span><br><span class="line">2 files changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line">create mode 100644 product.html</span><br><span class="line">create mode 100644 product.js</span><br></pre></td></tr></table></figure></li></ol><p>在 <code>develop</code> 分支新增的 <code>product.html</code> 與 <code>product.js</code> 兩個檔案，因為主要分支 <code>master</code> 現在已經合併了 <code>develop</code> 分支，所以現在在主要分支 <code>master</code> 上也有這兩個檔案了。</p><div class="note danger">            <p>🔴<strong>注意</strong><br>所謂的 Merge 並不是指分支與分支之間的合併，而是去 Merge 「<strong>該分支所指向的那些 Commit</strong>」。</p>          </div><h4 id="快轉模式（Fast-Forward）">快轉模式（Fast Forward）</h4><p>快轉模式是指當主要分支 <code>master</code> 合併 <code>feature</code> 分支時，<code>master</code> 當前的節點一直和 <code>feature</code> 的根節點相同，沒有發生改變，此時就會採取「快轉模式」，其實就是把 <code>master</code> 這張貼紙撕起來，往前貼到 <code>feature</code> 分支所指的那個 Commit 而已。</p><p><img src="https://imgur.com/gh2tuar.gif" alt="fast forward"></p><h4 id="非快轉模式（No-Fast-Forward）">非快轉模式（No Fast Forward）</h4><p>當主要分支 <code>master</code> 當前的節點與 <code>feature</code> 分支的根節點不同時，此時合併分支並不會觸發快轉模式，會額外產出一個 Commit。</p><p><img src="https://imgur.com/kiAcFZ6.gif" alt="no fast forward"></p><h3 id="另一種合併方式：rebase">另一種合併方式：rebase</h3><p>rebase 這個英文單字的翻譯是「重新定義分支的<strong>參考基準</strong>」。Rebase 合併分支跟 Merge 合併分支最明顯的差異在於，使用 Rebase 合併分支，Git 不會特別產生一個專門用來合併的 Commit。</p><blockquote><p>A <code>git rebase</code> copies the commits from the current branch, and puts these copied commits on top of the specified branch.</p></blockquote><p><img src="https://imgur.com/OXgklx2.gif" alt="rebasing"></p><h4 id="rebase-參考資料">rebase 參考資料</h4><p><a href="https://gitbook.tw/chapters/branch/merge-with-rebase">另一種合併方式（使用 rebase）</a></p><h3 id="合併時發生衝突（Merge-Conflict）">合併時發生衝突（Merge Conflict）</h3><p>Git 有能力幫忙檢查簡單的衝突，所以並不是改到同一個檔案就一定會發生衝突，但是改到<strong>同一個檔案的同一行程式碼</strong>就沒辦法了。Git 無法幫你選擇哪一個當作最終版本，所以當發生衝突時，只能「自己手動調整」。</p><p>假設現在有一個 <code>index.html</code> 檔案，主要分支 <code>master</code> 與 <code>develop</code> 分支都同時修改了這個檔案，如果想要把 <code>develop</code> 分支 Merge 到主要分支 <code>master</code> 上，會出現以下訊息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git merge develop</span><br><span class="line">Auto-merging index.html</span><br><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> index.html</span><br><span class="line">Automatic merge failed; fix conflicts and <span class="keyword">then</span> commit the result.</span><br></pre></td></tr></table></figure><p>使用 <code>git status</code> 指令查詢目錄狀態：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (use <span class="string">&quot;git merge --abort&quot;</span> to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to mark resolution)</span><br><span class="line"></span><br><span class="line">        both modified:   index.html</span><br><span class="line"></span><br><span class="line">no changes added to commit (use <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure><blockquote><p>You have unmerged paths.</p></blockquote><p>你有一個未合併的路徑。意思就是<strong>目前的合併尚未完成</strong>。</p><p>進入 <code>index.html</code> 檔案會顯示衝突發生的位置，需要手動調整檔案內容：</p><p><img src="https://imgur.com/rSN5i9L.png" alt="merge conflict message"></p><p>Git 會把有衝突的段落標記出來了：</p><ul><li><p>上半部是 <code>HEAD</code>，也就是目前所在的主要分支 <code>master</code></p></li><li><p>中間是分隔線</p></li><li><p>下半部是被合併的分支，也就是 <code>develop</code> 分支</p></li></ul><p>修改完發生衝突的段落後，還是要把檔案重新安置到暫存區，並完成 Commit Message，才算解決 Merge Conflict。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add index.html</span><br><span class="line">$ git commit -m <span class="string">&#x27;conflict fixed&#x27;</span></span><br><span class="line">[master d634e31] conflict fixed</span><br></pre></td></tr></table></figure><p><img src="https://imgur.com/UWOIgkf.gif" alt="merge conflict"></p><h2 id="使用-GitHub-遠端共同協作">使用 GitHub 遠端共同協作</h2><p>Git 是一個分散式版本控制工具，藉由它可以產生一個儲存庫（Repository），裡面存放著被 Git 版本控制的專案。</p><p>GitHub 是目前全球最大的 Git Server，許多 Open-source 的專案都是使用 Github 進行程式碼的管理，可以把 GitHub 想成「<strong>提供存放 / 使用 Git 專案儲存庫（Repository）的服務</strong>」。</p><h3 id="將本地端-Repository-推送到遠端">將本地端 Repository 推送到遠端</h3><ol><li><p>在 Github 上建立一個 Repository</p><p><img src="https://imgur.com/zStUuVM.png" alt="create repository"></p></li><li><p>建立好遠端 Repository 後，有兩種方式將本地端 Repository 與 GitHub 的遠端 Repository 連結：</p><ul><li><p>如果是全新開始，依照「create a new repository on the command line」指示進行</p></li><li><p>如果是要上傳現存專案，依照「push an existing repository from the command line」指示進行</p></li></ul><p><img src="https://imgur.com/SXpZV0E.png" alt="remote guide"></p></li><li><p>以全新開始的專案為例：</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /desktop          </span><br><span class="line">$ <span class="built_in">mkdir</span> git-practice</span><br><span class="line">$ <span class="built_in">cd</span> git-practice</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;# Git Practice&#x27;</span> &gt;&gt; README.md</span><br><span class="line"></span><br><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> /desktop/git-practice/.git/</span><br><span class="line"></span><br><span class="line">$ git add README.md</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&#x27;initial commit&#x27;</span></span><br><span class="line">[master (root-commit) 542dc7e] initial commit</span><br><span class="line">1 file changed, 1 insertion(+)</span><br><span class="line">create mode 100644 README.md</span><br></pre></td></tr></table></figure></li><li><p>將本地端 Repository 推送到 GitHub</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote add origin https://github.com/avery210412/git-practice.git</span><br></pre></td></tr></table></figure><p>意思是「<strong>將本地端 Repository 新增一個名為 <code>origin</code> 的遠端 Repository</strong>」。</p><ul><li><p><code>git remote</code>：主要是跟遠端有關的操作</p></li><li><p><code>add</code>：要加入一個遠端的節點</p></li><li><p><code>origin</code>：是一個「代名詞」，指的是後面那串 GitHub 伺服器的位置</p></li></ul> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git push -u origin master</span><br><span class="line">Enumerating objects: 3, <span class="keyword">done</span>.</span><br><span class="line">Counting objects: 100% (3/3), <span class="keyword">done</span>.</span><br><span class="line">Writing objects: 100% (3/3), 229 bytes | 229.00 KiB/s, <span class="keyword">done</span>.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0), pack-reused 0</span><br><span class="line">To https://github.com/avery210412/git-practice.git</span><br><span class="line">* [new branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="built_in">set</span> up to track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure><p><code>git push</code> 指令其實做了幾件事：</p><ul><li><p>把 <code>master</code> 這個分支的內容，推向 <code>origin</code> 指向的 GitHub 伺服器位置</p></li><li><p>在 <code>origin</code> 指向的伺服器上，如果 <code>master</code> 分支不存在，就建立一個叫做 <code>master</code> 的同名分支。</p></li><li><p>如果伺服器上原本就存在 <code>master</code> 分支，便會移動伺服器上 <code>master</code> 分支的位置，使它指到目前最新的 Commit 上。</p></li><li><p><code>-u</code>：設定 <code>upstream</code>，使本地端分支開始追蹤指定的遠端分支，也就是說現在開始，「<strong>本地端的 <code>master</code> 分支，會去追蹤遠端 origin 上的 <code>master</code> 分支</strong>」</p></li></ul></li><li><p>回到瀏覽器上重新整理頁面：</p><p><img src="https://imgur.com/o7Jjyn1.png" alt="push repository finished"></p><p>看到這個畫面，表示已經順利把本地端 Repository 的東西，推送到這個遠端 Repository 裡面了。</p></li></ol><div class="note ">            <p>🌀<strong>狀況題</strong><br>如何修改已經 Push 到遠端的 Commit？</p><p>假設現在已經完成一個 Commit，並且也推送到遠端 Repository 上，如果此時專案中的檔案做了一些小修改，但是又不想在這個 Commit 以後再新增一個 Commit 記錄此次的修改，只想要修改上一次的 Commit 並且重新 Push 到遠端 Repository，可以這樣操作：</p><ol><li><p>使用 <code>--amend</code> 參數進行 Commit，來修改上一次的 Commit，此時 SHA-1 值會重新計算</p></li><li><p>使用 <code>git push --force-with-lease origin &lt;branch&gt;</code>，將 Commit 推送至遠端 Repository</p></li></ol>          </div><h4 id="git-push-參考資料"><code>git push</code> 參考資料</h4><p><a href="https://youtu.be/VShhhq_5sMc">如何使用 git push 指令只 Push 部份的進度？</a></p><p><a href="https://gitbook.tw/chapters/github/fail-to-push">怎麼有時候推不上去</a></p><p><a href="https://tinyurl.com/y6gtw7s8">修改已經 Push 到遠端 Repository 的 Commit</a></p><h3 id="將遠端-Repository-同步至本地端">將遠端 Repository 同步至本地端</h3><h4 id="Fetch">Fetch</h4><p>當本地端 Repository 已經推送到遠端時，目前的分支圖如下：</p><p><img src="https://imgur.com/TR4NUjH.png" alt="git branching diagram"></p><p>假使這個專案由多人協作開發，某位開發者 Push 了新的功能，此時遠端 Repository 就會新增一個 Commit：</p><p><img src="https://imgur.com/5Pngthu.png" alt="push a new feature"></p><p>此時，若想要把遠端 Repository 的最新版本下載回本地端，但又擔心下載後，會與本地端的 Repository 發生合併衝突（Merge Conflict）的情形，此時可以使用 <code>git fetch</code> 指令。</p><p>當執行 Fetch 指令時，Git 會看一下遠端 Repository 的最新版本內容，在比較一下此時本地端 Repository 的內容，它會<strong>把遠端有但是本地端沒有的內容</strong>下載到本地端 Repository，但是<strong>不會將這些內容合併到本地端 Repository</strong>，因此分支圖還是會維持上面的情況：</p><p><img src="https://imgur.com/5Pngthu.png" alt="git fetch"></p><p>由於 <code>origin/master</code> 這個遠端分支，是從本地端 <code>master</code> 分支推送到 GitHub 進而產生的，因此 <code>origin/master</code> 分支跟 <code>master</code> 分支<strong>本是同根生</strong>。如果要把 Fetch 得到的最新版本內容合併到本地端 Repository，會觸發快轉模式（Fast Forward），此時的分支圖如下：</p><p><img src="https://imgur.com/QUQ5aAH.png" alt="Fetch and Merge"></p><p><img src="https://imgur.com/tPCaQE5.gif" alt="Fetch"></p><h4 id="Pull">Pull</h4><blockquote><p><em>git pull = git fetch + git merge</em></p></blockquote><p>Pull 指令就是將遠端 Repository 的最新版本下載回本地端，並且將遠端分支合併到本地分支，也就是將 <code>origin/master</code> 這個遠端分支<strong>直接合併</strong>到本地端 <code>master</code> 分支。</p><p><img src="https://imgur.com/RtefJ9S.gif" alt="Pull"></p><h3 id="從-GitHub-伺服器上取得-Repository">從 GitHub 伺服器上取得 Repository</h3><p>如果在 GitHub 上看到某個專案很有趣，想要下載到本地端研究，使用 Clone 指令就可以把整個專案複製一份到本地端了。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/sparanoid/chinese-copywriting-guidelines.git</span><br><span class="line">Cloning into <span class="string">&#x27;chinese-copywriting-guidelines&#x27;</span>...</span><br><span class="line">remote: Enumerating objects: 907, <span class="keyword">done</span>.</span><br><span class="line">remote: Counting objects: 100% (212/212), <span class="keyword">done</span>.</span><br><span class="line">remote: Compressing objects: 100% (98/98), <span class="keyword">done</span>.</span><br><span class="line">remote: Total 907 (delta 137), reused 181 (delta 113), pack-reused 695</span><br><span class="line">Receiving objects: 100% (907/907), 354.90 KiB | 2.25 MiB/s, <span class="keyword">done</span>.</span><br><span class="line">Resolving deltas: 100% (529/529), <span class="keyword">done</span>.</span><br></pre></td></tr></table></figure><p>Clone 指令會把整個專案的內容複製一份到本地端，也就是你的電腦裡，這裡指的「內容」不是只有檔案，而是指<strong>整個專案的歷史紀錄、分支、標籤等</strong>內容都會複製一份下來。</p><div class="note danger">            <p>🔴<strong>注意</strong><br>如果這個專案你是第一次看到，想要下載到你的電腦裡，請使用 Clone 指令；如果你已經下載過這個專案，只是想要更新最新的線上版本內容，請使用 Pull（Fetch）指令。<br><strong>Clone 指令通常只會在第一次下載時使用，Clone 之後的更新，就是 Pull / Fetch 的事了。</strong></p>          </div><h2 id="使用-GitHub-Flow-參與開源專案">使用 GitHub Flow 參與開源專案</h2><p>Git 儲存庫並沒有<strong>權限控管</strong>的概念。當越多人參與同一個專案，每個人都有存取這個儲存庫的權限時，可能會遇到一些協同開發上的問題，例如：每個人都可以 Commit 到專案正式上線的分支（例如：<code>master</code>），在這種情況下，不同人彼此之間的程式碼會互相干擾。</p><p>GitHub 提供了 Fork 與 Pull Request 的機制，賦予儲存庫基本的權限控管。</p><h3 id="GitHub-Flow">GitHub Flow</h3><p><img src="https://i.imgur.com/gns2luN.png" alt="GitHub Flow"></p><p>GitHub Flow 是一個基於分支（branch）的輕量化工作流程，藉由分支去管理功能的開發，以及來自社群的貢獻。</p><p>遵守 GitHub Flow 進行開發有一個規則：<strong><code>master</code> 分支必須保持隨時可以部屬正式環境（Production Ready）的狀態</strong>。</p><h3 id="GitHub-Flow-步驟">GitHub Flow 步驟</h3><h4 id="Fork">Fork</h4><p><img src="https://imgur.com/Oq2TpJc.png" alt="fork repository"></p><p>如果想要參與一個你沒有推送（Push）權限的專案，可以先複製（<strong>Fork</strong>）一份原始專案的<strong>副本</strong>到自己的 GitHub 帳號底下，你對這個副本有全部的權限，之後的任何修改都在這個副本中執行。</p><p>所有人都可以 Fork 專案，對 Fork 出來的副本推送變更，然後去發送 Pull Request，來把這些變更貢獻回原始專案裡。</p><blockquote><p>Fork 這個字在這邊翻譯成「複製」並不是這個字的原意，在技術圈來說這個詞使用的情境是「原作的做的不夠好，其它人覺得可以做得更好，或是想加入一些個人喜好的功能，而修改出另外的版本」。</p></blockquote><h4 id="Branch">Branch</h4><p><img src="https://i.imgur.com/YxNhiqA.png" alt="Create Branch"></p><p>將副本 Clone 到本地端，第一件事情就是<strong>建立新分支</strong>，之後的修改和討論都會<strong>以這個分支為基準</strong>。</p><p>在專案建立一個分支，代表建立了一個環境來開發功能，在分支上所做的修改，都不會影響到 <code>master</code> 分支，所以可以自由的嘗試並提交修改。</p><h4 id="Commits">Commits</h4><p><img src="https://i.imgur.com/ehEeTyx.png" alt="Add Commits"></p><p>在對專案進行功能開發、修改之前，執行 <code>git remote -v</code> 查看 Git 的遠端設定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/avery210412/chinese-copywriting-guidelines.git (fetch)</span><br><span class="line">origin  https://github.com/avery210412/chinese-copywriting-guidelines.git (push)</span><br></pre></td></tr></table></figure><p>建議對 Git 的遠端設定進行調整，<strong>將 fetch 的遠端位置，改成原始專案的位置</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin https://github.com/sparanoid/chinese-copywriting-guidelines.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/sparanoid/chinese-copywriting-guidelines.git (fetch)</span><br><span class="line">origin  https://github.com/sparanoid/chinese-copywriting-guidelines.git (push)</span><br><span class="line"></span><br><span class="line">$ git remote set-url --push origin https://github.com/avery210412/chinese-copywriting-guidelines.git</span><br><span class="line">$ git remote -v</span><br><span class="line">origin  https://github.com/sparanoid/chinese-copywriting-guidelines.git (fetch)</span><br><span class="line">origin  https://github.com/avery210412/chinese-copywriting-guidelines.git (push)</span><br></pre></td></tr></table></figure><p>這樣設定可以達到以下好處：</p><ul><li><p>之後會從原始專案中取得最新的專案資料（fetch），保持專案的一致性</p></li><li><p>所有修改的資料只會推送到自己的專案中（push），不會影響到其他人</p></li></ul><p>完成設定後，就可以對專案進行功能開發。</p><h4 id="Pull-Request">Pull Request</h4><p><img src="https://i.imgur.com/1XdLZa1.png" alt="Open Pull Request"></p><p>功能開發完成後，將本地端的 Repository 推送到遠端的 GitHub Repository。</p><p>此時可以在 GitHub 上建立一個 Pull Request，Pull Request 提供了一個方式法來通知專案維護者，是否考慮使用你所做的修改。</p><p>這邊特別說明一件事，每個專案可能都有自己的規範，通常會寫在專案的 <code>README.md</code> 或是 <code>CONTRIBUTING.md</code>，請務必在修改或提交前，閱讀專案的規範，維持開源專案的品質。</p><h4 id="Discuss-And-Review">Discuss And Review</h4><p><img src="https://i.imgur.com/ser2wXQ.png" alt="Discuss And Review"></p><p>專案維護者在檢視你所貢獻的程式碼後，可以在該 PR 中進行討論，討論程式碼內容或關於修改的建議，過程中如果有需要修改的地方，可以直接在該分支中做修改，因為 PR 是看分支的，所以該分支於 PR 確認合併前，都可以新增 Commit，並納入該 PR 中。</p><h4 id="Deploy">Deploy</h4><p><img src="https://imgur.com/ibRwwDN.png" alt="Test Deploy"></p><p>正式合併到 <code>master</code> 分支之前，在這個階段可以先部署到測試環境，以進行合併前的最終測試。如果測試沒有通過或產生任何可以討論的議題，則可以取消合併，在通過一系列的測試後，才可以發佈到正式環境（Production Ready）上。</p><h4 id="Merge">Merge</h4><p><img src="https://i.imgur.com/IYJgbY5.png" alt="Merge"></p><p>當所貢獻的程式碼經過一連串的檢閱、測試後，具有<strong>原始專案合併權限的人</strong>，就可以將你的貢獻合併到原始專案中了，你也成為原始專案的貢獻者（Contributions）之一了。</p><h4 id="GitHub-Flow-參考資料">GitHub Flow 參考資料</h4><p><a href="https://blog.poychang.net/guide-to-use-github-flow/">如何使用 GitHub Flow 來參與開源專案</a></p><p><a href="https://reurl.cc/1ZYDqp">讓我們來了解 GitHub Flow 吧！</a></p><h2 id="總結">總結</h2><p><img src="https://i.imgur.com/zzNkt5X.jpg" alt="Git Cheat Sheet"></p><h3 id="Git-版本控制參考資料">Git 版本控制參考資料</h3><p><a href="https://gitbook.tw/">為你自己學 Git</a></p><p><a href="https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1">CS Visualized: Useful Git Commands</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言-2&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;在軟體開發領域，對原始碼進行&lt;strong&gt;版本控管&lt;/strong&gt;是非常重要的一件事。Git 是一套分散式版本控管系統（Distributed Version Control System），支援本地操作、遠端協作、彈性的分支與合併、原始碼審核（Code Review）等功能，對專案原始碼的品質管理很有幫助。&lt;/p&gt;</summary>
    
    
    
    <category term="tool" scheme="https://avery210412.github.io/categories/tool/"/>
    
    
    <category term="Lidemy" scheme="https://avery210412.github.io/tags/Lidemy/"/>
    
    <category term="Git" scheme="https://avery210412.github.io/tags/Git/"/>
    
    <category term="GitHub" scheme="https://avery210412.github.io/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>[CMD101] Command Line Interface</title>
    <link href="https://avery210412.github.io/tool/command-line-interface/"/>
    <id>https://avery210412.github.io/tool/command-line-interface/</id>
    <published>2022-04-28T04:03:00.000Z</published>
    <updated>2022-04-29T03:35:30.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言">前言</h2><p><strong>命令列介面</strong>（CLI）是在<strong>圖形使用者介面</strong>（GUI）得到普及之前，使用最為廣泛的使用者介面，通常認為 CLI 沒有 GUI 那麼方便操作，是因為 CLI 需要使用者記憶操作的指令，通過鍵盤輸入指令，電腦接收到指令後予以執行。</p><span id="more"></span><h2 id="What-is-CLI？">What is CLI？</h2><p><img src="https://imgur.com/HpO14MU.png" alt="CLI v.s. GUI"></p><p>相較於圖形使用者介面（Graphical User Interface, GUI）透過點擊圖示（icon），開啟圖形化視窗操作電腦的方式，命令列介面（Command Line Interface, CLI）是一種以<strong>文本</strong>為主的應用程式，使用者透過輸入指令，與電腦進行溝通。</p><p>雖然現在的電腦系統都提供了圖形化的操作方式，但並沒有停止提供文字模式的命令列操作方式。使用 CLI 有以下主因：</p><ul><li><p>速度</p><p>GUI 操作電腦的原理，也是在調用 CLI 指令，直接輸入 CLI 指令操作電腦更快速。</p></li><li><p>功能</p><p>GUI 只有涵蓋一般使用者<strong>常用</strong>的電腦操作指令，CLI 對於<strong>電腦系統</strong>有更精確的控制。</p><p>有些<strong>伺服器系統</strong>例如：資料庫（Database），由於資源的考量，並不支援 GUI 操作系統，因此只能使用 CLI 與伺服器進行溝通。</p></li><li><p>自動化</p><p>當需要大規模處理邏輯相同的任務時，透過 CLI 撰寫腳本語言（Scripting language），可以更輕鬆的管理系統。</p></li></ul><h2 id="常用指令">常用指令</h2><h3 id="目錄與檔案管理">目錄與檔案管理</h3><table><thead><tr><th>指令</th><th>名稱</th><th>功能</th></tr></thead><tbody><tr><td><code>pwd</code></td><td>Print Working Directory</td><td>顯示目前所在的目錄</td></tr><tr><td><code>cd</code></td><td>Change Directory</td><td>切換目錄</td></tr><tr><td><code>ls</code></td><td>List</td><td>列出當前所在目錄的檔案清單</td></tr><tr><td><code>ls -a</code></td><td></td><td>列出當前所在目錄的檔案清單，包含<strong>隱藏檔</strong></td></tr><tr><td><code>ls -l</code></td><td></td><td>以<strong>長資料</strong>的形式，列出當前所在目錄的檔案清單（包含檔案屬性與權限）</td></tr><tr><td><code>mkdir</code></td><td>Make Directory</td><td>建立新目錄</td></tr><tr><td><code>rmdir</code></td><td>Remove Directory</td><td>刪除「空」目錄</td></tr><tr><td><code>cp</code></td><td>Copy</td><td>複製檔案</td></tr><tr><td><code>cp -r</code></td><td></td><td>複製目錄</td></tr><tr><td><code>mv</code></td><td>Move</td><td><strong>移動</strong>檔案或目錄 / <strong>變更檔名</strong></td></tr><tr><td><code>rm</code></td><td>Remove</td><td>移除檔案</td></tr><tr><td><code>rm -r</code></td><td></td><td>移除目錄</td></tr></tbody></table><div class="note danger">            <p>🔴<strong>注意</strong><br>使用 <code>rmdir</code> 刪除目錄時，被刪除的目錄裡面必定不能存在其他的目錄或檔案。<br>當目錄裡面還有子目錄時，使用 <code>rm -r</code> 指令，該目錄與其子目錄會一併被刪除。</p>          </div><h3 id="目錄與路徑">目錄與路徑</h3><ul><li><p>絕對路徑</p><p>由<strong>根目錄</strong>（<code>/</code>）開始寫起的檔名或目錄名稱。</p><p>範例：移至 <code>/usr/share/doc</code> 目錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> /usr/share/doc</span><br></pre></td></tr></table></figure></li><li><p>相對路徑</p><p>相對於<strong>目前路徑</strong>的檔名或目錄名稱。</p><p>範例：從 <code>/usr/share/doc</code> 目錄移至 <code>/usr/share/man</code> 目錄</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ../man</span><br></pre></td></tr></table></figure></li><li><p>切換目錄（<code>cd</code>）的操作</p><table><thead><tr><th>符號</th><th>定義</th></tr></thead><tbody><tr><td><code>.</code></td><td>同一層目錄</td></tr><tr><td><code>..</code></td><td>上一層目錄</td></tr><tr><td><code>-</code></td><td>前一個工作目錄</td></tr><tr><td><code>~</code></td><td>家目錄</td></tr></tbody></table></li></ul><h3 id="檔案內容查閱">檔案內容查閱</h3><table><thead><tr><th>指令</th><th>名稱</th><th>功能</th></tr></thead><tbody><tr><td><code>touch</code></td><td>Touch</td><td>修改檔案時間 / 建立新檔案</td></tr><tr><td><code>cat</code></td><td>Concatenate</td><td>將檔案內容<strong>完整</strong>顯示在 Terminal 畫面中</td></tr><tr><td><code>less</code></td><td>Less</td><td>將檔案內容以<strong>分頁</strong>形式顯示在 Terminal 畫面中</td></tr><tr><td><code>head</code></td><td>Head</td><td>取出檔案前面幾行的內容</td></tr><tr><td><code>tail</code></td><td>Tail</td><td>取出檔案後面幾行的內容</td></tr><tr><td><code>file</code></td><td>File</td><td>檢查檔案類型</td></tr></tbody></table><h3 id="Vim-編輯文字檔案">Vim 編輯文字檔案</h3><p>Vim 主要是使用<strong>模式的切換</strong>來進行輸入、移動游標、選取、複製及貼上等操作。Vim 常用的模式有兩種：<strong>Normal 模式</strong>以及 <strong>Insert 模式</strong>。</p><p><img src="https://i.imgur.com/s3Kool3.png" alt="Vim"></p><ul><li><p>Normal 模式：無法輸入文字，僅能進行複製、貼上、存檔或離開動作。</p></li><li><p>Insert 模式：可以編輯文字檔案。</p></li><li><p>透過 Vim 打開文檔後，輸入 <code>i</code>、<code>a</code> 或 <code>o</code>，進入 Insert 模式。</p></li><li><p>文檔編輯結束，輸入 <code>Ese</code>，回到 Normal 模式。</p></li><li><p>在 Normal 模式下，輸入 <code>:wq</code> 執行存檔並關閉檔案，退出 Vim 編輯器。</p></li><li><p>常用來編輯 Git Commit 訊息。</p></li></ul><h3 id="網路相關指令">網路相關指令</h3><ul><li><p><code>ping</code>：網路檢測工具，檢查自己與特定設備之間的網路是否暢通</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ping google.com</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Pinging google.com [172.217.163.46] with 32 bytes of data:</span><br><span class="line">Reply from 172.217.163.46: bytes=32 time=9ms TTL=113</span><br><span class="line">Reply from 172.217.163.46: bytes=32 time=9ms TTL=113</span><br><span class="line">Reply from 172.217.163.46: bytes=32 time=8ms TTL=113</span><br><span class="line">Reply from 172.217.163.46: bytes=32 time=13ms TTL=113</span><br><span class="line"></span><br><span class="line">Ping statistics for 172.217.163.46:</span><br><span class="line">    Packets: Sent = 4, Received = 4, Lost = 0 (0% loss),</span><br><span class="line">Approximate round trip times in milli-seconds:</span><br><span class="line">    Minimum = 8ms, Maximum = 13ms, Average = 9ms</span><br></pre></td></tr></table></figure></li><li><p><code>nslookup</code>：查詢 DNS 回應是否正常</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nslookup google.com</span><br></pre></td></tr></table></figure><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Non-authoritative answer:</span><br><span class="line">Server:  hitronhub.home</span><br><span class="line">Address:  192.168.0.1</span><br><span class="line"></span><br><span class="line">Name:  google.com</span><br><span class="line">Addresses:  2404:6800:4012:4::200e</span><br><span class="line">            172.217.163.46</span><br></pre></td></tr></table></figure></li><li><p><code>wget</code>：下載網路資源至當前目錄。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget google.com</span><br></pre></td></tr></table></figure><p>將 <code>google.com</code> 的 <strong>html 頁面</strong>下載至當前目錄。</p></li><li><p><code>curl</code>：與 <code>wget</code> 相似，可以用來下載網路資源，但功能比 <code>wget</code> 更強大，使用 <code>curl</code> 進行 HTTP Request，可以測試 Restful api。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -X POST -H <span class="string">&#x27;Content-Type: application/json&#x27;</span> -d <span class="string">&#x27;&#123;&quot;name&quot;: &quot;Avery&quot;&#125;&#x27;</span> <span class="string">&#x27;https://www.example.com/api/members&#x27;</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="其他常用指令">其他常用指令</h3><table><thead><tr><th>指令</th><th>名稱</th><th>功能</th></tr></thead><tbody><tr><td><code>clear</code></td><td>Clear</td><td>清除 Terminal 畫面</td></tr><tr><td><code>date</code></td><td>Date</td><td>印出當前日期</td></tr><tr><td><code>grep</code></td><td>Global Regular Expression Print</td><td>在指定檔案中尋找特定字串</td></tr><tr><td><code>echo</code></td><td>Echo</td><td>將字串輸出到 Terminal 畫面</td></tr><tr><td>|</td><td>Pipe</td><td>把前面指令的<strong>輸出</strong>，作為後面指令的<strong>輸入</strong></td></tr><tr><td><code>&gt;</code></td><td>Redirect</td><td>重新導向</td></tr></tbody></table><ul><li><p>Pipe 範例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> file.txt | grep Hello</span><br></pre></td></tr></table></figure><p>從印出的 file.txt 內容中，尋找字串 <code>Hello</code> 並輸出。</p></li><li><p>Redirect 範例</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;Hello&#x27;</span> &gt; file.txt</span><br></pre></td></tr></table></figure><p>產生字串 <code>Hello</code>，並覆蓋 file.txt 內容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&#x27;Hi&#x27;</span> &gt;&gt; file.txt</span><br></pre></td></tr></table></figure><p>產生字串 <code>Hi</code>，並將內容新增至 file.txt 最後面。</p></li></ul><h4 id="CLI-參考資料">CLI 參考資料</h4><p><a href="https://tableplus.com/blog/2018/08/cli-vs-gui-which-one-is-better.html">CLI vs GUI - Which one is better?</a></p><p><a href="https://blog.techbridge.cc/2017/12/23/linux-commnd-line-tutorial/">Linux Command 命令列指令與基本操作入門教學</a></p><p><a href="https://blog.techbridge.cc/2019/02/01/linux-curl-command-tutorial/">Linux Curl Command 指令與基本操作入門教學</a></p><p><a href="http://hackgrass.blogspot.com/2017/04/linuxunix-like-command-line.html">基礎 Linux（UNIX-Like）指令整理介紹</a></p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;命令列介面&lt;/strong&gt;（CLI）是在&lt;strong&gt;圖形使用者介面&lt;/strong&gt;（GUI）得到普及之前，使用最為廣泛的使用者介面，通常認為 CLI 沒有 GUI 那麼方便操作，是因為 CLI 需要使用者記憶操作的指令，通過鍵盤輸入指令，電腦接收到指令後予以執行。&lt;/p&gt;</summary>
    
    
    
    <category term="tool" scheme="https://avery210412.github.io/categories/tool/"/>
    
    
    <category term="Lidemy" scheme="https://avery210412.github.io/tags/Lidemy/"/>
    
    <category term="Command Line" scheme="https://avery210412.github.io/tags/Command-Line/"/>
    
  </entry>
  
</feed>
